{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Diffusion entropy analysis","text":"<p>Diffusion Entropy Analysis is a time-series analysis method for detecting temporal scaling in a data set, such as particle motion, a seismograph, or an electroencephalograph signal. Diffusion Entropy Analysis converts a timeseries into a diffusion trajectory and uses the entropy of this trajectory to measure the temporal scaling in the data. This is accomplished by moving a window along the trajectory, then using the relationship between the natural logarithm of the length of the window and the Shannon entropy to extract the scaling of the time-series process.</p> <p>For further details about the method and how it works, please see Culbreth, G., Baxley, J. and Lambert, D., 2023. Detecting temporal scaling with modified diffusion entropy analysis. arXiv preprint arXiv:2311.11453.</p>"},{"location":"#installation-and-use","title":"Installation and use","text":"<p>The pymdea package is available on pypi and can be installed with uv:</p> <pre><code>uv add pymdea\n</code></pre> <p>or with pip:</p> <pre><code>pip install pymdea\n</code></pre>"},{"location":"#built-with","title":"Built with","text":""},{"location":"api-reference/core/","title":"pymdea.core","text":"<p>Diffusion entropy analysis core methods.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine","title":"<code>DeaEngine(loader, hist_bins='doane', windows=250, window_stop=0.25)</code>","text":"<p>Run diffusion entropy analysis.</p> <p>Parameters:</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def __init__(\n    self: Self,\n    loader: DeaLoader,\n    hist_bins: int\n    | Literal[\"fd\", \"doane\", \"scott\", \"stone\", \"rice\", \"sturges\"] = \"doane\",\n    windows: int = 250,\n    window_stop: float = 0.25,\n) -&gt; Self:\n    \"\"\"Run diffusion entropy analysis.\n\n    Parameters\n    ----------\n    loader : DeaLoader\n        An instance of the DeaLoader class containing data to be\n        analysed.\n    hist_bins : int | {\"auto\", \"fd\", \"doane\", \"scott\", \"stone\", \"rice\", \"sturges\"}\n        Number of bins, or method by which to calculate it, to use\n        for the histogram in the Shannon entropy calculation. Refer\n        to `numpy.histogram_bin_edges` for details about the\n        binning methods.\n    window_stop : float\n        Proportion of data length at which to cap window length.\n        For example, if set to 0.25, 0.25 * len(data) will be the\n        maximum window length. Must be a float in (0, 1].\n    windows : int\n        Number of window lengths to use and fit over.\n        Window lengths will be evenly spaced in log-scale.\n\n    \"\"\"\n    console = Console()\n    logging.basicConfig(\n        level=\"INFO\",\n        format=\"%(funcName)s: %(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n        handlers=[RichHandler(console=console)],\n    )\n    self.log = logging.getLogger(\"rich\")\n    if window_stop &lt;= 0 or window_stop &gt; 1:\n        msg = f\"Parameter 'window_stop' must be in (0, 1], got: {window_stop}\"\n        raise ValueError(msg)\n    n_windows = int(np.floor(window_stop * len(loader.data)))\n    if windows &gt; n_windows:\n        msg = (\n            f\"Parameter max_fit={windows} longer than \"\n            f\"window_stop * len(data) = {n_windows}, \"\n            f\"{n_windows} will be used\"\n        )\n        self.log.warning(msg)\n    self.data = loader.data\n    self.hist_bins = hist_bins\n    self.window_stop = window_stop\n    self.max_fit = windows\n    self.progress = Progress(\n        SpinnerColumn(),\n        TextColumn(\"[progress.percentage]{task.percentage:&gt;3.0f}%\"),\n        BarColumn(),\n        TextColumn(\"eta\"),\n        TimeRemainingColumn(),\n        TextColumn(\"elapsed\"),\n        TimeElapsedColumn(),\n        console=console,\n    )\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine(loader)","title":"<code>loader</code>","text":"(<code>DeaLoader</code>)           \u2013            <p>An instance of the DeaLoader class containing data to be analysed.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine(hist_bins)","title":"<code>hist_bins</code>","text":"(<code>int | {auto, fd, doane, scott, stone, rice, sturges}</code>, default:                   <code>'doane'</code> )           \u2013            <p>Number of bins, or method by which to calculate it, to use for the histogram in the Shannon entropy calculation. Refer to <code>numpy.histogram_bin_edges</code> for details about the binning methods.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine(window_stop)","title":"<code>window_stop</code>","text":"(<code>float</code>, default:                   <code>0.25</code> )           \u2013            <p>Proportion of data length at which to cap window length. For example, if set to 0.25, 0.25 * len(data) will be the maximum window length. Must be a float in (0, 1].</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine(windows)","title":"<code>windows</code>","text":"(<code>int</code>, default:                   <code>250</code> )           \u2013            <p>Number of window lengths to use and fit over. Window lengths will be evenly spaced in log-scale.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_with_stripes","title":"<code>analyze_with_stripes(fit_start, fit_stop, fit_method='siegel', stripes=20)</code>","text":"<p>Run a modified diffusion entropy analysis.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self @ Engine</code>           \u2013            <p>Object containing the results and inputs of the diffusion entropy analysis.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If n_stripes &lt; 2. At least two stripes must be applied for DEA to provide a meaningful result.</p> </li> </ul> Notes <p>Prefer the siegel or theilsen methods. Least squares linear fits can introduce bias when done over log-scale data, see Clauset, A., Shalizi, C.R. and Newman, M.E., 2009. Power-law distributions in empirical data. SIAM review, 51(4), pp.661-703. https://doi.org/10.1137/070710111. https://arxiv.org/pdf/0706.1062.pdf.</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def analyze_with_stripes(\n    self: Self,\n    fit_start: int,\n    fit_stop: int,\n    fit_method: Literal[\"siegel\", \"theilsen\", \"ls\"] = \"siegel\",\n    stripes: int = 20,\n) -&gt; Self:\n    \"\"\"Run a modified diffusion entropy analysis.\n\n    Parameters\n    ----------\n    fit_start : float\n        Fraction of maximum window length at which to start linear fit.\n    fit_stop : float\n        Fraction of maximum window length at which to stop linear fit.\n    fit_method : str {\"siegel\", \"theilsen\", \"ls\"}, optional\n        Linear fit method to use. By default \"siegel\"\n    stripes : int, optional, default: 20\n        Number of stripes to apply to input time-series during\n        analysis.\n\n    Returns\n    -------\n    Self @ Engine\n        Object containing the results and inputs of the diffusion\n        entropy analysis.\n\n    Raises\n    ------\n    ValueError\n        If n_stripes &lt; 2. At least two stripes must be applied for\n        DEA to provide a meaningful result.\n\n    Notes\n    -----\n    Prefer the siegel or theilsen methods. Least squares linear\n    fits can introduce bias when done over log-scale data, see\n    Clauset, A., Shalizi, C.R. and Newman, M.E., 2009. Power-law\n    distributions in empirical data. SIAM review, 51(4), pp.661-703.\n    https://doi.org/10.1137/070710111.\n    https://arxiv.org/pdf/0706.1062.pdf.\n\n    \"\"\"\n    if stripes &lt; 2:  # noqa: PLR2004\n        msg = \"n_stripes must be greater than 1\"\n        raise ValueError(msg)\n    self.number_of_stripes = stripes\n    self.fit_start = fit_start\n    self.fit_stop = fit_stop\n    self.fit_method = fit_method\n    self._apply_stripes()\n    self._get_events()\n    self._make_trajectory()\n    self._calculate_entropy()\n    self._calculate_scaling()\n    self._calculate_mu()\n    self.print_result()\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_with_stripes(fit_start)","title":"<code>fit_start</code>","text":"(<code>float</code>)           \u2013            <p>Fraction of maximum window length at which to start linear fit.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_with_stripes(fit_stop)","title":"<code>fit_stop</code>","text":"(<code>float</code>)           \u2013            <p>Fraction of maximum window length at which to stop linear fit.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_with_stripes(fit_method)","title":"<code>fit_method</code>","text":"(<code>str {\"siegel\", \"theilsen\", \"ls\"}</code>, default:                   <code>'siegel'</code> )           \u2013            <p>Linear fit method to use. By default \"siegel\"</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_with_stripes(stripes)","title":"<code>stripes</code>","text":"(<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Number of stripes to apply to input time-series during analysis.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_without_stripes","title":"<code>analyze_without_stripes(fit_start, fit_stop, fit_method='siegel')</code>","text":"<p>Run a regular diffusion entropy analysis.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self @ Engine</code>           \u2013            <p>Object containing the results and inputs of the diffusion entropy analysis.</p> </li> </ul> Notes <p>Prefer the siegel or theilsen methods. Least squares linear fits can introduce bias when done over log-scale data, see Clauset, A., Shalizi, C.R. and Newman, M.E., 2009. Power-law distributions in empirical data. SIAM review, 51(4), pp.661-703. https://doi.org/10.1137/070710111. https://arxiv.org/pdf/0706.1062.pdf.</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def analyze_without_stripes(\n    self: Self,\n    fit_start: int,\n    fit_stop: int,\n    fit_method: Literal[\"siegel\", \"theilsen\", \"ls\"] = \"siegel\",\n) -&gt; Self:\n    \"\"\"Run a regular diffusion entropy analysis.\n\n    Parameters\n    ----------\n    fit_start : float\n        Fraction of maximum window length at which to start linear fit.\n    fit_stop : float\n        Fraction of maximum window length at which to stop linear fit.\n    fit_method : str {\"siegel\", \"theilsen\", \"ls\"}, optional\n        Linear fit method to use. By default \"siegel\"\n\n    Returns\n    -------\n    Self @ Engine\n        Object containing the results and inputs of the diffusion\n        entropy analysis.\n\n    Notes\n    -----\n    Prefer the siegel or theilsen methods. Least squares linear\n    fits can introduce bias when done over log-scale data, see\n    Clauset, A., Shalizi, C.R. and Newman, M.E., 2009. Power-law\n    distributions in empirical data. SIAM review, 51(4), pp.661-703.\n    https://doi.org/10.1137/070710111.\n    https://arxiv.org/pdf/0706.1062.pdf.\n\n    \"\"\"\n    self.trajectory = self.data\n    self.fit_start = fit_start\n    self.fit_stop = fit_stop\n    self.fit_method = fit_method\n    self._calculate_entropy()\n    self._calculate_scaling()\n    self._calculate_mu()\n    self.print_result()\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_without_stripes(fit_start)","title":"<code>fit_start</code>","text":"(<code>float</code>)           \u2013            <p>Fraction of maximum window length at which to start linear fit.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_without_stripes(fit_stop)","title":"<code>fit_stop</code>","text":"(<code>float</code>)           \u2013            <p>Fraction of maximum window length at which to stop linear fit.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_without_stripes(fit_method)","title":"<code>fit_method</code>","text":"(<code>str {\"siegel\", \"theilsen\", \"ls\"}</code>, default:                   <code>'siegel'</code> )           \u2013            <p>Linear fit method to use. By default \"siegel\"</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.print_result","title":"<code>print_result()</code>","text":"<p>Print out result of analysis.</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def print_result(self: Self) -&gt; str:\n    \"\"\"Print out result of analysis.\"\"\"\n    self.result = Table(box=box.SIMPLE)\n    self.result.add_column(\"\u03b4\")\n    self.result.add_column(\"\u03bc (rule 1)\")\n    self.result.add_column(\"\u03bc (rule 2)\")\n    self.result.add_column(\"\u03bc (rule 3)\")\n    self.result.add_row(\n        f\"{self.delta:.5f}\",\n        f\"{self.mu1:.5f}\",\n        f\"{self.mu2:.5f}\",\n        f\"{self.mu3:.5f}\",\n    )\n    console = Console()\n    console.print(self.result)\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader","title":"<code>DeaLoader()</code>","text":"<p>Load data for a diffusion entropy analysis.</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def __init__(self: Self) -&gt; Self:\n    \"\"\"Load data for a diffusion entropy analysis.\"\"\"\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.make_diffusion_process","title":"<code>make_diffusion_process(kind='gn', length=10000, a=0)</code>","text":"<p>Generate diffusion process data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self @ Loader</code>           \u2013            <p>An instance of the Loader object.</p> </li> </ul> Source code in <code>src/pymdea/core.py</code> <pre><code>def make_diffusion_process(\n    self: Self,\n    kind: Literal[\"cn\", \"gn\", \"fgn\", \"fbm\"] = \"gn\",\n    length: int = 10000,\n    a: float = 0,\n) -&gt; Self:\n    \"\"\"Generate diffusion process data.\n\n    Parameters\n    ----------\n    kind : str {\"cn\", \"gn\", \"fgn\", \"fbm\"}, optional, default \"cn\"\n        Type of diffusion noise to generate. If \"cn\", generate a\n        colored noise with spectral power `a`. If \"gn\", generate a\n        Gaussian noise. If \"fgn\", generate a fractional Gaussian\n        noise with Hurst index H = `a`. If \"fbm\", generate a\n        fractional Brownian motion with Hurst index H=`a`.\n    length : int, optional, default 10000\n        Length of time-series to generate.\n    a : float, optional, default 0\n        Only used if `kind` is \"fgn\", \"fbm\", or \"cn\". If `kind` is\n        \"fgn\" or \"fbm\", this sets the Hurst index of the process.\n        If `kind` is \"cn\" this sets the index of the power law\n        spectrum for the noise, 1/(f^`a`).\n\n    Returns\n    -------\n    Self @ Loader\n        An instance of the Loader object.\n\n    \"\"\"\n    if kind == \"gn\":\n        process = stochastic.processes.noise.GaussianNoise()\n        self.data = process.sample(length)\n    if kind == \"cn\":\n        process = stochastic.processes.noise.ColoredNoise(beta=a)\n        self.data = process.sample(length)\n    if kind == \"fgn\":\n        process = stochastic.processes.noise.FractionalGaussianNoise(hurst=a)\n        self.data = process.sample(length)\n    if kind == \"fbm\":\n        process = stochastic.processes.continuous.FractionalBrownianMotion(hurst=a)\n        self.data = process.sample(length)\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.make_diffusion_process(kind)","title":"<code>kind</code>","text":"(<code>str {\"cn\", \"gn\", \"fgn\", \"fbm\"}</code>, default:                   <code>\"cn\"</code> )           \u2013            <p>Type of diffusion noise to generate. If \"cn\", generate a colored noise with spectral power <code>a</code>. If \"gn\", generate a Gaussian noise. If \"fgn\", generate a fractional Gaussian noise with Hurst index H = <code>a</code>. If \"fbm\", generate a fractional Brownian motion with Hurst index H=<code>a</code>.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.make_diffusion_process(length)","title":"<code>length</code>","text":"(<code>int</code>, default:                   <code>10000</code> )           \u2013            <p>Length of time-series to generate.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.make_diffusion_process(a)","title":"<code>a</code>","text":"(<code>float</code>, default:                   <code>0</code> )           \u2013            <p>Only used if <code>kind</code> is \"fgn\", \"fbm\", or \"cn\". If <code>kind</code> is \"fgn\" or \"fbm\", this sets the Hurst index of the process. If <code>kind</code> is \"cn\" this sets the index of the power law spectrum for the noise, 1/(f^<code>a</code>).</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.make_sample_data","title":"<code>make_sample_data(length=100000, seed=1)</code>","text":"<p>Generate an array of sample data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self @ Loader</code>           \u2013            <p>An instance of the Loader object.</p> </li> </ul> Source code in <code>src/pymdea/core.py</code> <pre><code>def make_sample_data(self: Self, length: int = 100000, seed: int = 1) -&gt; np.ndarray:\n    \"\"\"Generate an array of sample data.\n\n    Parameters\n    ----------\n    length : int, optional, default: 100000\n        Number of time-steps to produce in the sample data.\n    seed : int, optional, default: 1\n        Seed for random number generation.\n\n    Returns\n    -------\n    Self @ Loader\n        An instance of the Loader object.\n\n    \"\"\"\n    rng = np.random.default_rng(seed=seed)\n    random_walk = rng.choice([-1, 1], size=length).cumsum()\n    random_walk[0] = 0  # always start from 0\n    self.seed = seed\n    self.data = random_walk\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.make_sample_data(length)","title":"<code>length</code>","text":"(<code>int</code>, default:                   <code>100000</code> )           \u2013            <p>Number of time-steps to produce in the sample data.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.make_sample_data(seed)","title":"<code>seed</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Seed for random number generation.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.read_data_file","title":"<code>read_data_file(filepath, column_name)</code>","text":"<p>Read input data from file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Self @ Loader</code>           \u2013            <p>An instance of the Loader object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If filepath points to a file of type other than CSV. Support for more types of files is a work in progress.</p> </li> </ul> Source code in <code>src/pymdea/core.py</code> <pre><code>def read_data_file(self: Self, filepath: str, column_name: str) -&gt; pl.DataFrame:\n    \"\"\"Read input data from file.\n\n    Parameters\n    ----------\n    filepath : str\n        System path to a file containing data. Must include the\n        full file name, including the extension. Example:\n        \"/example/path/to/file.csv\"\n    column_name : str\n        Name of the column in the data file which contains the time\n        series data values.\n\n    Returns\n    -------\n    Self @ Loader\n        An instance of the Loader object.\n\n    Raises\n    ------\n    ValueError\n        If filepath points to a file of type other than\n        CSV. Support for more types of files is a work in\n        progress.\n\n    \"\"\"\n    filepath = Path(filepath)\n    supported_types = [\".csv\"]\n    if filepath.suffix not in supported_types:\n        msg = f\"filetype must be one of: {supported_types}.\"\n        raise ValueError(msg)\n    if filepath.suffix == \".csv\":\n        self.data = pl.scan_csv(filepath).select(column_name).to_numpy()\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.read_data_file(filepath)","title":"<code>filepath</code>","text":"(<code>str</code>)           \u2013            <p>System path to a file containing data. Must include the full file name, including the extension. Example: \"/example/path/to/file.csv\"</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.read_data_file(column_name)","title":"<code>column_name</code>","text":"(<code>str</code>)           \u2013            <p>Name of the column in the data file which contains the time series data values.</p>"},{"location":"api-reference/plot/","title":"pymdea.plot","text":"<p>Plotting functions.</p>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter","title":"<code>DeaPlotter(model, theme=None)</code>","text":"<p>Plot DEA results.</p> <p>Parameters:</p> Source code in <code>src/pymdea/plot.py</code> <pre><code>def __init__(\n    self: Self,\n    model: DeaEngine,\n    theme: None | str = None,\n) -&gt; Self:\n    \"\"\"Plot DEA results.\n\n    Parameters\n    ----------\n    model : Self@DeaEngine\n        Object containing the results of a DEA analysis to be plotted.\n    theme : None | str, optional, default: None\n        Must be either None or a string corresponding to a\n        matplotlib.pyplot style.\n\n    \"\"\"\n    if theme is not None:\n        plt.style.use(style=theme)\n    self.window_lengths = model.window_lengths\n    self.entropies = model.entropies\n    self.delta = model.fit_coefficients[0]\n    self.y_intercept = model.fit_coefficients[1]\n    self.mu1 = model.mu1\n    self.mu2 = model.mu2\n    self.mu3 = model.mu3\n</code></pre>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter(model)","title":"<code>model</code>","text":"(<code>Self @ DeaEngine</code>)           \u2013            <p>Object containing the results of a DEA analysis to be plotted.</p>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter(theme)","title":"<code>theme</code>","text":"(<code>None | str</code>, default:                   <code>None</code> )           \u2013            <p>Must be either None or a string corresponding to a matplotlib.pyplot style.</p>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter.mu_candidates","title":"<code>mu_candidates(fig_width=5, fig_height=3)</code>","text":"<p>Plot the possible values of mu.</p> <p>Parameters:</p> Source code in <code>src/pymdea/plot.py</code> <pre><code>def mu_candidates(self: Self, fig_width: int = 5, fig_height: int = 3) -&gt; None:\n    \"\"\"Plot the possible values of mu.\n\n    Parameters\n    ----------\n    fig_width : int, optional, default: 4\n        Width, in inches, of the figure.\n    fig_height : int, optional, default: 3\n        Height, in inches, of the figure.\n\n    \"\"\"\n    x1 = np.linspace(1, 2, 100)\n    x2 = np.linspace(2, 3, 100)\n    x3 = np.linspace(3, 4, 100)\n    y1 = x1 - 1\n    y2 = 1 / (x2 - 1)\n    y3 = np.full(100, 0.5)\n\n    fig, ax = plt.subplots(figsize=(fig_width, fig_height), layout=\"constrained\")\n    ax.plot(x1, y1, color=\"k\")\n    ax.plot(x2, y2, color=\"k\")\n    ax.plot(x3, y3, color=\"k\")\n    ax.plot(\n        self.mu1,\n        self.delta,\n        marker=\"o\",\n        fillstyle=\"none\",\n        markersize=5,\n        markeredgewidth=2,\n        linestyle=\"none\",\n        label=f\"$\\\\mu$ = {np.round(self.mu1, 2)}\",\n    )\n    ax.plot(\n        self.mu2,\n        self.delta,\n        marker=\"o\",\n        fillstyle=\"none\",\n        markersize=5,\n        markeredgewidth=2,\n        linestyle=\"none\",\n        label=f\"$\\\\mu$ = {np.round(self.mu2, 2)}\",\n    )\n    ax.plot(\n        self.mu3,\n        self.delta,\n        marker=\"o\",\n        fillstyle=\"none\",\n        markersize=5,\n        markeredgewidth=2,\n        linestyle=\"none\",\n        label=f\"$\\\\mu$ = {np.round(self.mu3, 2)}\",\n    )\n    ax.set_xticks(ticks=np.linspace(1, 4, 7))\n    ax.set_yticks(ticks=np.linspace(0, 1, 5))\n    ax.set_xlabel(\"$\\\\mu$\")\n    ax.set_ylabel(\"$\\\\delta$\")\n    ax.legend(loc=\"center left\", bbox_to_anchor=(1.0, 0.5))\n    ax.grid(visible=True)\n    sns.despine(left=True, bottom=True)\n    self.fig_mu_candidates = fig\n</code></pre>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter.mu_candidates(fig_width)","title":"<code>fig_width</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Width, in inches, of the figure.</p>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter.mu_candidates(fig_height)","title":"<code>fig_height</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Height, in inches, of the figure.</p>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter.s_vs_l","title":"<code>s_vs_l(fig_width=5, fig_height=3)</code>","text":"<p>Plot the slope of entropy vs window length.</p> <p>Parameters:</p> Source code in <code>src/pymdea/plot.py</code> <pre><code>def s_vs_l(self: Self, fig_width: int = 5, fig_height: int = 3) -&gt; None:\n    \"\"\"Plot the slope of entropy vs window length.\n\n    Parameters\n    ----------\n    fig_width : int, optional, default: 4\n        Width, in inches, of the figure.\n    fig_height : int, optional, default: 3\n        Height, in inches, of the figure.\n\n    \"\"\"\n    x_line = np.linspace(start=1, stop=np.max(self.window_lengths), num=3)\n    fig, ax = plt.subplots(figsize=(fig_width, fig_height), layout=\"constrained\")\n    ax.plot(\n        self.window_lengths,\n        self.entropies,\n        linestyle=\"none\",\n        marker=\"o\",\n        markersize=3,\n        fillstyle=\"none\",\n    )\n    ax.plot(\n        x_line,\n        self.delta * np.log(x_line) + self.y_intercept,\n        color=\"k\",\n        label=f\"$\\\\delta = {np.round(self.delta, 3)}$\",\n    )\n    ax.set_xscale(\"log\")\n    ax.set_xlabel(\"$\\\\ln(L)$\")\n    ax.set_ylabel(\"$S(L)$\")\n    ax.legend(loc=\"center left\", bbox_to_anchor=(1.0, 0.5))\n    sns.despine(trim=True)\n    self.fig_s_vs_l = fig\n</code></pre>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter.s_vs_l(fig_width)","title":"<code>fig_width</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Width, in inches, of the figure.</p>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter.s_vs_l(fig_height)","title":"<code>fig_height</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Height, in inches, of the figure.</p>"},{"location":"user-guide/further-reading/","title":"Further reading","text":""},{"location":"user-guide/further-reading/#culbreth-g-baxley-j-and-lambert-d-2023","title":"Culbreth, G., Baxley, J. and Lambert, D., 2023","text":"<p>Culbreth, G., Baxley, J. and Lambert, D., 2023. Detecting temporal scaling with modified diffusion entropy analysis. arXiv preprint arXiv:2311.11453</p>"},{"location":"user-guide/further-reading/#culbreth-g-west-bj-and-grigolini-p-2019","title":"Culbreth, G., West, B.J. and Grigolini, P., 2019","text":"<p>Culbreth, G., West, B.J. and Grigolini, P., 2019. Entropic approach to the detection of crucial events. Entropy, 21(2), p.178. doi:10.3390/e21020178</p> <p>Note</p> <ul> <li>This paper introduced the stripes and describes their role with figure examples.</li> <li>This paper used \\(\\eta\\) to denote scaling, rather than \\(\\delta\\).</li> </ul>"},{"location":"user-guide/further-reading/#scafetta-n-and-grigolini-p-2002","title":"Scafetta, N. and Grigolini, P., 2002","text":"<p>Scafetta, N. and Grigolini, P., 2002. Scaling detection in time series: Diffusion entropy analysis. Physical Review E, 66(3), p.036130. doi:10.1103/PhysRevE.66.036130</p> <p>Note</p> <p>The actual algorithm for DEA is detailed (mostly only in words) in Section IV.</p>"},{"location":"user-guide/further-reading/#grigolini-p-palatella-l-and-raffaelli-g-2001","title":"Grigolini, P., Palatella, L. and Raffaelli, G., 2001","text":"<p>Grigolini, P., Palatella, L. and Raffaelli, G., 2001. Asymmetric anomalous diffusion: an efficient way to detect memory in time series. Fractals, 9(04), pp.439-449. doi:10.1142/S0218348X01000865</p> <p>Note</p> <p>This paper introduced always using positive steps when constructing the event array, rather than the sign of the step at that time index.</p>"},{"location":"user-guide/getting-started/","title":"Getting started","text":""},{"location":"user-guide/getting-started/#setting-up","title":"Setting up","text":"<p>pymdea is available on PyPI and can be installed with:</p> <pre><code>pip install pymdea\n</code></pre> <p>or can be installed from PyPI with uv:</p> <pre><code>uv add pymdea\n</code></pre> Building from source with uv <p>Install the uv python project manager, following the instructions on uv's official installation guide.</p> <p>Using a command line terminal, clone the pymdea repository to a location on your file system:</p> <pre><code>git clone https://github.com/garland-culbreth/pymdea.git /example/file/path/pymdea.git\n</code></pre> <p>Navigate to the cloned repository directory:</p> <pre><code>cd /example/file/path/pymdea.git\n</code></pre> <p>and run the uv command:</p> <pre><code>uv sync\n</code></pre> <p>This will create a python virtual environment in a subdirectory called <code>.../pymdea.git/.venv</code> which contains a python executable and all packages necessary to run pymdea. The command will display text output in the command line, which should look like this:</p> <pre><code>\u276f uv sync\nUsing Python 3.12.5\nCreating virtualenv at: .venv\nResolved 107 packages in 1.01s\nBuilt pymdea @ file:///D:/repos/pymdea.git\nPrepared 101 packages in 819ms\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 [0/101] Installing\nInstalled 101 packages in 5.05s\n+ asttokens==2.4.1\n+ attrs==24.2.0\n+ babel==2.16.0\n... (all 101 packages uv installs will be listed out)\n</code></pre> <p>Note: the file path, <code>D:/repos/pymdea.git</code>, is the directory on my own file system where my clone of pymdea is located.</p> <p>To confirm the files work properly, run the uv command:</p> <pre><code>uv run pytest\n</code></pre> <p>This runs the pymdea test suite from <code>test_core.py</code> and display a summary of the results in the command line output.</p> <p>Once pymdea is installed, you're ready to import the pymdea.core and pymdea.plot modules and work with them!</p>"},{"location":"user-guide/getting-started/#loading-pymdea","title":"Loading pymdea","text":"<p>Import from the pymdea modules as you would any Python package.</p> <pre><code>from pymdea.core import DeaEngine, DeaLoader\nfrom pymdea.plot import DeaPlotter\n</code></pre>"},{"location":"user-guide/getting-started/#loading-data","title":"Loading data","text":"<p>The <code>pymdea.core</code> module provides a <code>DeaLoader</code> class with helper methods for wrangling data. It also has a <code>make_sample_data</code> method for generating sample data for testing purposes, which is what this notebook will use to illustrate an example workflow.</p> <pre><code>dea_loader = DeaLoader()\ndea_loader.make_sample_data(30000)\n</code></pre>"},{"location":"user-guide/getting-started/#analyzing-data","title":"Analyzing data","text":"<p>The <code>DeaEngine</code> class from <code>pymdea.core</code> contains the methods for analyzing data once it's been loaded. Pass <code>DeaLoader</code> to <code>DeaEngine</code> to pass the data from the loader to the engine, then invoke the <code>analyze</code> method to run an analysis.</p> <pre><code>dea_engine = DeaEngine(dea_loader)\ndea_engine.analyze_with_stripes(fit_start=0.1, fit_stop=0.9, stripes=60)\n</code></pre> <pre><code>100% \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 eta 0:00:00 elapsed 0:00:00\n\n\u03b4         \u03bc (rule 1)   \u03bc (rule 2)   \u03bc (rule 3)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n0.50781   1.50781      2.96924      1.49219\n</code></pre>"},{"location":"user-guide/getting-started/#viewing-results","title":"Viewing results","text":"<p>The <code>DeaPlotter</code> class from <code>pymdea.plot</code> contains methods for viewing the results and producing plots. Pass <code>DeaEngine</code> to <code>DeaPlotter</code> to pass the results from the engine to the plotter, then invoke the plotting methods to view different summaries of the results.</p> <pre><code>dea_plot = DeaPlotter(dea_engine)\n</code></pre> <p>The most illustrative figure is plotting the Shannon entropy against the log of the window lengths, S(L) vs ln(L):</p> <pre><code>dea_plot.s_vs_l()\n</code></pre> <p></p> <p>It's also useful to quickly compare the results of the different rules for computing the mu parameter:</p> <pre><code>dea_plot.mu_candidates()\n</code></pre> <p></p>"},{"location":"user-guide/interpreting/","title":"Interpreting results","text":""},{"location":"user-guide/interpreting/#fundamentals-and-notation","title":"Fundamentals and notation","text":"<p>The measured scaling of the time-series process is \\(\\delta\\).</p> <p>The \\(\\mu\\) is a complexity index, defined as the power for the inter-event time distribution, \\(\\frac{1}{\\tau^\\mu}\\), where \\(\\tau\\) is inter-event time.</p>"},{"location":"user-guide/interpreting/#frames-of-reference","title":"Frames of reference","text":"<p>For a totally random process, DEA yields \\(\\delta = 0.5\\).</p> <p>The closer \\(\\delta\\) is to 1, and the closer \\(\\mu\\) is to 2, the more complex the data-series is. Those are the critical values of \\(\\delta\\) and \\(\\mu\\).</p> <p>If \\(\\delta &lt; 0.5\\) this may mean the time-series is not complex in the way DEA is designed to quantify (work in this area is ongoing).</p>"},{"location":"user-guide/interpreting/#calculating-mu","title":"Calculating mu","text":"<p>Three rules of calculating \\(\\mu\\) are supported:</p> <ol> <li>\\(\\mu = 1 + \\delta\\), holds when \\(1 &lt; \\mu &lt; 2\\)</li> <li>\\(\\mu = 1 + \\frac{1}{\\delta}\\), holds when \\(2 &lt; \\mu &lt; 3\\)</li> <li>\\(\\mu = 2 - \\delta\\), holds when \\(1 &lt; \\mu &lt; 2\\)</li> </ol> <p>The correct rule for any particular analysis may vary. Because rigorous rules for determining which is correct in what situation have yet to be laid down, all candidates are calculated and plotted so that users can compare them. Typically the correct value for will lie along the line, since that line represents the theoretical relationship. If you already have an expectation for what rule \\(\\mu\\) should follow, e.g., from theoretical arguments, use that.</p> <p>The theoretical justifications for the two methods of deriving from the scaling are given in Section 3.2 of Scafetta, N., &amp; Grigolini, P. (2002) and Section 3.1\u20123.2 of Grigolini, P., Palatella, L., &amp; Raffaelli, G. (2001).</p>"},{"location":"user-guide/tuning/","title":"Tuning an analysis","text":""},{"location":"user-guide/tuning/#number-of-stripes","title":"Number of stripes","text":"<p>Warning</p> <p>Rigorous rules for choosing the proper number of stripes are still being developed.</p> <p>Run a few initial tests with different values. e.g. 10, 50, 100. If there is significant disagreement in the scalings measured, vary about those trial numbers. The correct number of stripes to use is that number such that when varied up or down a little, the scaling does not change.</p>"},{"location":"user-guide/tuning/#fit-interval","title":"Fit interval","text":"<p>In the result figure plotting \\(S(l)\\) vs \\(\\ln(l)\\), if the results are good there should be a region that appears linear. You want the fit interval to cover this region. \\(S(l)\\) is logged in calculation, \\(\\ln(l)\\) is logged by the scale of the plot. The fitting function accounts for this.</p>"},{"location":"user-guide/tuning/#histogram-binning-method","title":"Histogram binning method","text":"<p>At each window length in the analysis, a histogram is constructed to represent the probability density function of the diffusion trajectory slices corresponding to that window length. To give valid results, the histogram must accurately represent the probability density function.</p> <p>There is no histogram method that's always best. You can read more about the available methods in NumPy's <code>numpy.histogram_bin_edges</code> documentation. The default method for pymdea is the <code>doane</code> method; it performs reasonably well in most cases and is better suited to non-normal distributions than some of the others.</p>"},{"location":"user-guide/tuning/#maximum-window-length","title":"Maximum window length","text":"<p>The <code>window_length_stop</code> option in <code>DeaEngine</code> specifies what the longest window length used in the analysis should be, as a proportion of the data series' length. The default setting for this options is 0.25; that is 1/4th the overall data series length. Window lengths longer than this often begin to have difficulty resolving the underlying probability density. In some cases longer window lengths can be reasonable.</p> <p>As window length approaches the overall length of the data series there are fewer and fewer diffusion trajectories, and consequently the histogram for the window length's diffusion trajectories begins to poorly represent the probability density. This is apparent when plotting \\(S(l)\\) vs \\(\\ln(l)\\), e.g., with <code>DeaPlot.s_vs_l</code>. When the window lengths become too long to give good statistics, the corresponding entropies rapidly decreases and fall off.</p>"},{"location":"user-guide/tuning/#number-of-window-lengths","title":"Number of window lengths","text":"<p>The <code>max_fit</code> option in <code>DeaEngine</code> specifies the maximum number of window lengths used in the analysis. The default value is 250, which is enough to give good statistics from the linear fit but few enough not to bloat runtime. Increasing this is rarely necessary. Decreasing this can speed up analysis, and is especially useful for very long input data series, e.g., when the series has \\(10^7\\) or more points.</p>"}]}